#!/usr/bin/env bash

# Set the script to exit immediately if any command exits with a non-zero status
set -e

# Extract the name of the script without the path
cli_name="${0##*/}"

# Source a common library file from the specified location
source "$CLI_WORKDIR/lib/common"

# Import a configuration file
importFile "$CLI_WORKDIR/../.conf"

# Function to print basic usage information
cli_help() {
    cli_usage
    exit 1
}

# Function to print detailed usage information
cli_usage() {
    COMMANDS=$(ls) # This should probably be changed to COMMANDS=$(ls)
    echo "
Usage: $cli_name [-e|--env <TEST_ENV> <functionName>]

Available options:
   -e | --env,      for the test environment
   -n | --no-build, skip building the template
   -d | --debug,    debug features
   -h | --help,     for help
"
    exit 1
}

# Array to store positional arguments
POSITIONAL_ARGS=()
DEBUG_FLAG=""

# Loop through command-line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
    # --event)
    #     EVENT="$2"
    #     shift 2 # skip both the argument and its value
    #     ;;
    -e | --env)
        TEST_ENV="$2"
        shift 2 # skip both the argument and its value
        ;;
    -n | --no-build)
        NO_BUILD=true
        shift # skip the argument
        ;;
    -d | --debug)
        DEBUG_FLAG="--debug"
        shift # skip the argument
        ;;
    -h | --help)
        cli_help
        ;;
    -* | --*)
        echo "Unknown option $1"
        cli_help
        ;;
    *)
        POSITIONAL_ARGS+=("$1") # save positional arg
        shift                   # skip the argument
        ;;
    esac
done

# Restore positional parameters
set -- "${POSITIONAL_ARGS[@]}"

# Check if a function name is provided
if [[ -n $1 ]]; then
    LAMBDA_NAME=$1
fi

# Check if function name is missing
if [ -z "$LAMBDA_NAME" ]; then
    echo "Error: <functionName> is required."
    cli_help
fi

# Check if test environment is missing
if [ -z "${TEST_ENV}" ]; then
    if [ -n "$ENV" ]; then

        TEST_ENV=$ENV

        # Prompt the user with the '(Y/n)' option
        read -p "Using $ENV from .env file? (Y/n) " TEST_ENV

        # Check if the input is empty or not 'Y' or 'y', and set a default value
        if [ -z "$TEST_ENV" ] || [[ ! "$TEST_ENV" =~ ^[Yy]$ ]]; then
            TEST_ENV="N"
        fi

        # Now, $TEST_ENV contains the user's choice (either 'Y' or 'N')
        echo "Selected option: $TEST_ENV"

        TEST_ENV=$ENV
        # echo "$TEST_ENV"
    else
        read -p "Enter the test environment name: " TEST_ENV
        echo "Error: [-e|--env] <TEST_ENV> is required."
        cli_help
    fi
fi

# Set the project path to the current working directory
PROJECT_PATH=$(pwd)
HANDLERS_PATH="src/handler"

# Construct the full path to the Lambda function
LAMBDA_PATH="$PROJECT_PATH/$HANDLERS_PATH/$LAMBDA_NAME"

# Check if the Lambda function file exists
if [ ! -e "$LAMBDA_PATH/index.ts" ]; then
    error "ðŸ›‘ File '$LAMBDA_PATH/index.ts' does not exist. Performing additional actions."
fi

# Options for SAM Local invocation
EVENT_OPTS=""
# if [ [-n "$EVENT"] && [ -e "$LAMBDA_PATH/$EVENT"] ]; then
#     EVENT_OPTS="-e $LAMBDA_PATH/$EVENT"
# else
#     # Check for event configuration files
if [ -e "$LAMBDA_PATH/event.json" ]; then
    EVENT_OPTS="-e $LAMBDA_PATH/event.json"
fi
if [ -e "$LAMBDA_PATH/event-local.json" ]; then
    EVENT_OPTS="-e $LAMBDA_PATH/event-local.json"
fi
if [ -e "$LAMBDA_PATH/event-$TEST_ENV.json" ]; then
    EVENT_OPTS="-e $LAMBDA_PATH/event-$TEST_ENV.json"
fi
# fi
if [ -z "${EVENT_OPTS}" ]; then
    error "ðŸ›‘ No corresponding event in $LAMBDA_PATH/"
else
    debug "Event options: '$EVENT_OPTS'"
fi

# Check for local (env vars) configuration files
LOCAL_OPTS=""
if [ -e "$LAMBDA_PATH/local.json" ]; then
    LOCAL_OPTS="-n $LAMBDA_PATH/local.json"
fi
if [ -e "$LAMBDA_PATH/local-$TEST_ENV.json" ]; then
    LOCAL_OPTS="-n $LAMBDA_PATH/local-$TEST_ENV.json"
fi

if [ -z "${LOCAL_OPTS}" ]; then
    error "ðŸ›‘ No corresponding local in $LAMBDA_PATH/"
else
    debug "Local options: '$LOCAL_OPTS'"
fi

# Modify Lambda stack name for functions containing "resolver"
if [[ $LAMBDA_NAME == *"resolver"* ]]; then
    prefix="${LAMBDA_NAME%%-resolver*}"
    new_word="$(tr '-' '\n' <<<"$prefix" | awk '{print toupper(substr($0,1,1)) tolower(substr($0,2))}' | tr -d '\n')-resolver"
    LAMBDA_STACKNAME="$new_word-$TEST_ENV"
else
    LAMBDA_STACKNAME="$LAMBDA_NAME"
fi

# Restore positional parameters
set -- "${POSITIONAL_ARGS[@]}"

CDK_FOLDER="cdk.out"
CDK_TEMPLATE_PATH="$CDK_FOLDER/tf-backend-$TEST_ENV.template.json"
timestamp=$(date +%T)
# LOGS_PATH=$CLI_WORKDIR/logs$PROJECT_PATH

# Synthesize AWS CloudFormation template and invoke Lambda function locally
if [ "$NO_BUILD" != true ]; then
    cli_log "Building template" &&
        ENV="$TEST_ENV" npx cdk synth --quiet &&
        (cli_log "Building template succeeded âœ…") ||
        (echoerror "Building template failed ðŸ›‘")
fi

cli_log "Testing: '$LAMBDA_NAME' in '$TEST_ENV'" &&
    echo "$LAMBDA_STACKNAME" &&
    (
        ENV="$TEST_ENV" sam local invoke $LAMBDA_STACKNAME \
            $EVENT_OPTS \
            $LOCAL_OPTS \
            $DEBUG_FLAG \
            --template $CDK_TEMPLATE_PATH
    ) &&
    rm -rf "$CDK_FOLDER"

# Function to read a configuration file
