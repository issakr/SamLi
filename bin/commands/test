#!/usr/bin/env bash

# Set the script to exit immediately if any command exits with a non-zero status
set -e

# Extract the name of the script without the path
cli_name="${0##*/}"

# Source a common library file from the specified location
source "$CLI_WORKDIR/lib/common"

# Import a configuration file
importFile "$CLI_WORKDIR/../.conf"

# Function to print basic usage information
cli_help() {
    cli_usage
    exit 1
}

# Function to print detailed usage information
cli_usage() {
    COMMANDS=$(ls) # This should probably be changed to COMMANDS=$(ls)
    echo "
Usage: $cli_name [-e|--env <TEST_ENV> <functionName>]

Available options:
   -e | --env,   for the test environment
   -n | --no-build, skip building the template
   -h | --help,  for help
"
    exit 1
}

# Array to store positional arguments
POSITIONAL_ARGS=()

# Loop through command-line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
    -e | --env)
        TEST_ENV="$2"
        shift 2 # skip both the argument and its value
        ;;
    -n | --no-build)
        NO_BUILD=true
        shift # skip the argument
        ;;
    -h | --help)
        cli_help
        ;;
    -* | --*)
        echo "Unknown option $1"
        cli_help
        ;;
    *)
        POSITIONAL_ARGS+=("$1") # save positional arg
        shift                   # skip the argument
        ;;
    esac
done

# Restore positional parameters
set -- "${POSITIONAL_ARGS[@]}"

# Check if a function name is provided
if [[ -n $1 ]]; then
    LAMBDA_NAME=$1
fi

# Check if function name is missing
if [ -z "$LAMBDA_NAME" ]; then
    echo "Error: <functionName> is required."
    cli_help
fi

# Check if test environment is missing
if [ -z "${TEST_ENV}" ]; then
    if [ -n "$ENV" ]; then
        echo "Using $ENV from .env file"
        TEST_ENV=$ENV
        echo "$TEST_ENV"
    else
        echo "Error: [-e|--env] <TEST_ENV> is required."
        cli_help
    fi
fi

# Set the project path to the current working directory
PROJECT_PATH=$(pwd)
HANDLERS_PATH="src/handler"

# Construct the full path to the Lambda function
LAMBDA_PATH="$PROJECT_PATH/$HANDLERS_PATH/$LAMBDA_NAME"

# Check if the Lambda function file exists
if [ ! -e "$LAMBDA_PATH/index.ts" ]; then
    error "ðŸ›‘ File '$LAMBDA_PATH/index.ts' does not exist. Performing additional actions."
fi

# Options for SAM Local invocation
EVENT_OPTS=""
# Check for event configuration files
if [ -e "$LAMBDA_PATH/event.json" ]; then
    EVENT_OPTS="-e $LAMBDA_PATH/event.json"
fi
if [ -e "$LAMBDA_PATH/event-$TEST_ENV.json" ]; then
    EVENT_OPTS="-e $LAMBDA_PATH/event-$TEST_ENV.json"
fi
if [ -z "${EVENT_OPTS}" ]; then
    error "ðŸ›‘ No corresponding event in $LAMBDA_PATH/"
else
    debug "Event options: '$EVENT_OPTS'"
fi

# Check for local (env vars) configuration files
LOCAL_OPTS=""
if [ -e "$LAMBDA_PATH/local.json" ]; then
    LOCAL_OPTS="-n $LAMBDA_PATH/local.json"
fi
if [ -e "$LAMBDA_PATH/local-$TEST_ENV.json" ]; then
    LOCAL_OPTS="-n $LAMBDA_PATH/local-$TEST_ENV.json"
fi

if [ -z "${LOCAL_OPTS}" ]; then
    error "ðŸ›‘ No corresponding local in $LAMBDA_PATH/"
else
    debug "Local options: '$LOCAL_OPTS'"
fi
echo "$LOCAL_OPTS"

# Modify Lambda stack name for functions containing "resolver"
if [[ $LAMBDA_NAME == *"resolver"* ]]; then
    prefix="${LAMBDA_NAME%%-resolver*}"
    new_word="$(tr '-' '\n' <<<"$prefix" | awk '{print toupper(substr($0,1,1)) tolower(substr($0,2))}' | tr -d '\n')-resolver"
    LAMBDA_STACKNAME="$new_word-$TEST_ENV"
else
    LAMBDA_STACKNAME=$LAMBDA_NAME
fi

CDK_FOLDER="cdk.out"
CDK_TEMPLATE_PATH="$CDK_FOLDER/tf-backend-$TEST_ENV.template.json"

# Synthesize AWS CloudFormation template and invoke Lambda function locally
if [ "$NO_BUILD" != true ]; then
    cli_log "Building template" &&
        ENV="$TEST_ENV" npx cdk synth --quiet &&
        (cli_log "Building template succeeded âœ…") ||
        (echoerror "Building template failed ðŸ›‘")
fi

cli_log "Testing: $LAMBDA_NAME in $TEST_ENV" &&
    (ENV="$TEST_ENV" sam local invoke "$LAMBDA_STACKNAME" \
        "$EVENT_OPTS" "$LOCAL_OPTS" \
        --template "$CDK_TEMPLATE_PATH") && rm -rf "$CDK_FOLDER"

# Function to read a configuration file
function readConfigFile() {
    sysconfdir="$PROJECT_PATH"
    CONFIG_FILE="tfconfig.yml"
    CONFIG_FILE_PATH="$sysconfdir/$CONFIG_FILE_NAME"

    if test -f "$sysconfdir"; then
        echo "yes $sysconfdir"
        . "$sysconfdir"
    fi
    CONFIG_PARAM1=$(yq eval '.template_file.name' "$CONFIG_FILE")
}
